import { a as __toESM, t as __commonJS } from "./chunk-D8D7cWU-.js";
import { t as _extends } from "./extends-MDRD-mWY.js";
import { t as require_dayjs_min } from "./dayjs.min-DClX6hbg.js";
import { t as warnOnce } from "./warning-DZEVYkNm.js";

//#region node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekOfYear.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekOfYear = t();
	})(exports, (function() {
		var e = "week", t = "year";
		return function(i, n, r) {
			var f = n.prototype;
			f.week = function(i$1) {
				if (void 0 === i$1 && (i$1 = null), null !== i$1) return this.add(7 * (i$1 - this.week()), "day");
				var n$1 = this.$locale().yearStart || 1;
				if (11 === this.month() && this.date() > 25) {
					var f$1 = r(this).startOf(t).add(1, t).date(n$1), s = r(this).endOf(e);
					if (f$1.isBefore(s)) return 1;
				}
				var a = r(this).startOf(t).date(n$1).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, !0);
				return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
			}, f.weeks = function(e$1) {
				return void 0 === e$1 && (e$1 = null), this.week(e$1);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/customParseFormat.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
	})(exports, (function() {
		var e = {
			LTS: "h:mm:ss A",
			LT: "h:mm A",
			L: "MM/DD/YYYY",
			LL: "MMMM D, YYYY",
			LLL: "MMMM D, YYYY h:mm A",
			LLLL: "dddd, MMMM D, YYYY h:mm A"
		}, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e$1) {
			return (e$1 = +e$1) + (e$1 > 68 ? 1900 : 2e3);
		};
		var f = function(e$1) {
			return function(t$1) {
				this[e$1] = +t$1;
			};
		}, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e$1) {
			(this.zone || (this.zone = {})).offset = function(e$2) {
				if (!e$2) return 0;
				if ("Z" === e$2) return 0;
				var t$1 = e$2.match(/([+-]|\d\d)/g), n$1 = 60 * t$1[1] + (+t$1[2] || 0);
				return 0 === n$1 ? 0 : "+" === t$1[0] ? -n$1 : n$1;
			}(e$1);
		}], u = function(e$1) {
			var t$1 = s[e$1];
			return t$1 && (t$1.indexOf ? t$1 : t$1.s.concat(t$1.f));
		}, d = function(e$1, t$1) {
			var n$1, r$1 = s.meridiem;
			if (r$1) {
				for (var i$1 = 1; i$1 <= 24; i$1 += 1) if (e$1.indexOf(r$1(i$1, 0, t$1)) > -1) {
					n$1 = i$1 > 12;
					break;
				}
			} else n$1 = e$1 === (t$1 ? "pm" : "PM");
			return n$1;
		}, c = {
			A: [o, function(e$1) {
				this.afternoon = d(e$1, !1);
			}],
			a: [o, function(e$1) {
				this.afternoon = d(e$1, !0);
			}],
			Q: [n, function(e$1) {
				this.month = 3 * (e$1 - 1) + 1;
			}],
			S: [n, function(e$1) {
				this.milliseconds = 100 * +e$1;
			}],
			SS: [r, function(e$1) {
				this.milliseconds = 10 * +e$1;
			}],
			SSS: [/\d{3}/, function(e$1) {
				this.milliseconds = +e$1;
			}],
			s: [i, f("seconds")],
			ss: [i, f("seconds")],
			m: [i, f("minutes")],
			mm: [i, f("minutes")],
			H: [i, f("hours")],
			h: [i, f("hours")],
			HH: [i, f("hours")],
			hh: [i, f("hours")],
			D: [i, f("day")],
			DD: [r, f("day")],
			Do: [o, function(e$1) {
				var t$1 = s.ordinal;
				if (this.day = e$1.match(/\d+/)[0], t$1) for (var r$1 = 1; r$1 <= 31; r$1 += 1) t$1(r$1).replace(/\[|\]/g, "") === e$1 && (this.day = r$1);
			}],
			w: [i, f("week")],
			ww: [r, f("week")],
			M: [i, f("month")],
			MM: [r, f("month")],
			MMM: [o, function(e$1) {
				var t$1 = u("months"), n$1 = (u("monthsShort") || t$1.map((function(e$2) {
					return e$2.slice(0, 3);
				}))).indexOf(e$1) + 1;
				if (n$1 < 1) throw new Error();
				this.month = n$1 % 12 || n$1;
			}],
			MMMM: [o, function(e$1) {
				var t$1 = u("months").indexOf(e$1) + 1;
				if (t$1 < 1) throw new Error();
				this.month = t$1 % 12 || t$1;
			}],
			Y: [/[+-]?\d+/, f("year")],
			YY: [r, function(e$1) {
				this.year = a(e$1);
			}],
			YYYY: [/\d{4}/, f("year")],
			Z: h,
			ZZ: h
		};
		function l(n$1) {
			var r$1 = n$1, i$1 = s && s.formats;
			for (var o$1 = (n$1 = r$1.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t$1, n$2, r$2) {
				var o$2 = r$2 && r$2.toUpperCase();
				return n$2 || i$1[r$2] || e[r$2] || i$1[o$2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e$1, t$2, n$3) {
					return t$2 || n$3.slice(1);
				}));
			}))).match(t), a$1 = o$1.length, f$1 = 0; f$1 < a$1; f$1 += 1) {
				var h$1 = o$1[f$1], u$1 = c[h$1], d$1 = u$1 && u$1[0], l$1 = u$1 && u$1[1];
				o$1[f$1] = l$1 ? {
					regex: d$1,
					parser: l$1
				} : h$1.replace(/^\[|\]$/g, "");
			}
			return function(e$1) {
				for (var t$1 = {}, n$2 = 0, r$2 = 0; n$2 < a$1; n$2 += 1) {
					var i$2 = o$1[n$2];
					if ("string" == typeof i$2) r$2 += i$2.length;
					else {
						var s$1 = i$2.regex, f$2 = i$2.parser, h$2 = e$1.slice(r$2), u$2 = s$1.exec(h$2)[0];
						f$2.call(t$1, u$2), e$1 = e$1.replace(u$2, "");
					}
				}
				return function(e$2) {
					var t$2 = e$2.afternoon;
					if (void 0 !== t$2) {
						var n$3 = e$2.hours;
						t$2 ? n$3 < 12 && (e$2.hours += 12) : 12 === n$3 && (e$2.hours = 0), delete e$2.afternoon;
					}
				}(t$1), t$1;
			};
		}
		return function(e$1, t$1, n$1) {
			n$1.p.customParseFormat = !0, e$1 && e$1.parseTwoDigitYear && (a = e$1.parseTwoDigitYear);
			var r$1 = t$1.prototype, i$1 = r$1.parse;
			r$1.parse = function(e$2) {
				var t$2 = e$2.date, r$2 = e$2.utc, o$1 = e$2.args;
				this.$u = r$2;
				var a$1 = o$1[1];
				if ("string" == typeof a$1) {
					var f$1 = !0 === o$1[2], h$1 = !0 === o$1[3], u$1 = f$1 || h$1, d$1 = o$1[2];
					h$1 && (d$1 = o$1[2]), s = this.$locale(), !f$1 && d$1 && (s = n$1.Ls[d$1]), this.$d = function(e$3, t$3, n$2, r$3) {
						try {
							if (["x", "X"].indexOf(t$3) > -1) return /* @__PURE__ */ new Date(("X" === t$3 ? 1e3 : 1) * e$3);
							var i$2 = l(t$3)(e$3), o$2 = i$2.year, s$1 = i$2.month, a$2 = i$2.day, f$2 = i$2.hours, h$2 = i$2.minutes, u$2 = i$2.seconds, d$2 = i$2.milliseconds, c$2 = i$2.zone, m$1 = i$2.week, M$1 = /* @__PURE__ */ new Date(), Y = a$2 || (o$2 || s$1 ? 1 : M$1.getDate()), p = o$2 || M$1.getFullYear(), v = 0;
							o$2 && !s$1 || (v = s$1 > 0 ? s$1 - 1 : M$1.getMonth());
							var D, w = f$2 || 0, g = h$2 || 0, y = u$2 || 0, L = d$2 || 0;
							return c$2 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c$2.offset * 1e3)) : n$2 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m$1 && (D = r$3(D).week(m$1).toDate()), D);
						} catch (e$4) {
							return /* @__PURE__ */ new Date("");
						}
					}(t$2, a$1, r$2, n$1), this.init(), d$1 && !0 !== d$1 && (this.$L = this.locale(d$1).$L), u$1 && t$2 != this.format(a$1) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
				} else if (a$1 instanceof Array) for (var c$1 = a$1.length, m = 1; m <= c$1; m += 1) {
					o$1[1] = a$1[m - 1];
					var M = n$1.apply(this, o$1);
					if (M.isValid()) {
						this.$d = M.$d, this.$L = M.$L, this.init();
						break;
					}
					m === c$1 && (this.$d = /* @__PURE__ */ new Date(""));
				}
				else i$1.call(this, e$2);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/localizedFormat.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_localizedFormat = t();
	})(exports, (function() {
		var e = {
			LTS: "h:mm:ss A",
			LT: "h:mm A",
			L: "MM/DD/YYYY",
			LL: "MMMM D, YYYY",
			LLL: "MMMM D, YYYY h:mm A",
			LLLL: "dddd, MMMM D, YYYY h:mm A"
		};
		return function(t, o, n) {
			var r = o.prototype, i = r.format;
			n.en.formats = e, r.format = function(t$1) {
				void 0 === t$1 && (t$1 = "YYYY-MM-DDTHH:mm:ssZ");
				var o$1 = this.$locale().formats, n$1 = function(t$2, o$2) {
					return t$2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t$3, n$2, r$1) {
						var i$1 = r$1 && r$1.toUpperCase();
						return n$2 || o$2[r$1] || e[r$1] || o$2[i$1].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e$1, t$4, o$3) {
							return t$4 || o$3.slice(1);
						}));
					}));
				}(t$1, void 0 === o$1 ? {} : o$1);
				return i.call(this, n$1);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/isBetween.js
var require_isBetween = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/isBetween.js": ((exports, module) => {
	(function(e, i) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isBetween = i();
	})(exports, (function() {
		return function(e, i, t) {
			i.prototype.isBetween = function(e$1, i$1, s, f) {
				var n = t(e$1), o = t(i$1), r = "(" === (f = f || "()")[0], u = ")" === f[1];
				return (r ? this.isAfter(n, s) : !this.isBefore(n, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r ? this.isBefore(n, s) : !this.isAfter(n, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/advancedFormat.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
	})(exports, (function() {
		return function(e, t) {
			var r = t.prototype, n = r.format;
			r.format = function(e$1) {
				var t$1 = this, r$1 = this.$locale();
				if (!this.isValid()) return n.bind(this)(e$1);
				var s = this.$utils(), a = (e$1 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e$2) {
					switch (e$2) {
						case "Q": return Math.ceil((t$1.$M + 1) / 3);
						case "Do": return r$1.ordinal(t$1.$D);
						case "gggg": return t$1.weekYear();
						case "GGGG": return t$1.isoWeekYear();
						case "wo": return r$1.ordinal(t$1.week(), "W");
						case "w":
						case "ww": return s.s(t$1.week(), "w" === e$2 ? 1 : 2, "0");
						case "W":
						case "WW": return s.s(t$1.isoWeek(), "W" === e$2 ? 1 : 2, "0");
						case "k":
						case "kk": return s.s(String(0 === t$1.$H ? 24 : t$1.$H), "k" === e$2 ? 1 : 2, "0");
						case "X": return Math.floor(t$1.$d.getTime() / 1e3);
						case "x": return t$1.$d.getTime();
						case "z": return "[" + t$1.offsetName() + "]";
						case "zzz": return "[" + t$1.offsetName("long") + "]";
						default: return e$2;
					}
				}));
				return n.bind(this)(a);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/@mui/x-date-pickers/esm/AdapterDayjs/AdapterDayjs.js
/* v8 ignore stop */
var import_dayjs_min = /* @__PURE__ */ __toESM(require_dayjs_min(), 1);
var import_weekOfYear = /* @__PURE__ */ __toESM(require_weekOfYear(), 1);
var import_customParseFormat = /* @__PURE__ */ __toESM(require_customParseFormat(), 1);
var import_localizedFormat = /* @__PURE__ */ __toESM(require_localizedFormat(), 1);
var import_isBetween = /* @__PURE__ */ __toESM(require_isBetween(), 1);
var import_advancedFormat = /* @__PURE__ */ __toESM(require_advancedFormat(), 1);
import_dayjs_min.default.extend(import_localizedFormat.default);
import_dayjs_min.default.extend(import_weekOfYear.default);
import_dayjs_min.default.extend(import_isBetween.default);
import_dayjs_min.default.extend(import_advancedFormat.default);
var formatTokenMap = {
	YY: "year",
	YYYY: {
		sectionType: "year",
		contentType: "digit",
		maxLength: 4
	},
	M: {
		sectionType: "month",
		contentType: "digit",
		maxLength: 2
	},
	MM: "month",
	MMM: {
		sectionType: "month",
		contentType: "letter"
	},
	MMMM: {
		sectionType: "month",
		contentType: "letter"
	},
	D: {
		sectionType: "day",
		contentType: "digit",
		maxLength: 2
	},
	DD: "day",
	Do: {
		sectionType: "day",
		contentType: "digit-with-letter"
	},
	d: {
		sectionType: "weekDay",
		contentType: "digit",
		maxLength: 2
	},
	dd: {
		sectionType: "weekDay",
		contentType: "letter"
	},
	ddd: {
		sectionType: "weekDay",
		contentType: "letter"
	},
	dddd: {
		sectionType: "weekDay",
		contentType: "letter"
	},
	A: "meridiem",
	a: "meridiem",
	H: {
		sectionType: "hours",
		contentType: "digit",
		maxLength: 2
	},
	HH: "hours",
	h: {
		sectionType: "hours",
		contentType: "digit",
		maxLength: 2
	},
	hh: "hours",
	m: {
		sectionType: "minutes",
		contentType: "digit",
		maxLength: 2
	},
	mm: "minutes",
	s: {
		sectionType: "seconds",
		contentType: "digit",
		maxLength: 2
	},
	ss: "seconds"
};
var defaultFormats = {
	year: "YYYY",
	month: "MMMM",
	monthShort: "MMM",
	dayOfMonth: "D",
	dayOfMonthFull: "Do",
	weekday: "dddd",
	weekdayShort: "dd",
	hours24h: "HH",
	hours12h: "hh",
	meridiem: "A",
	minutes: "mm",
	seconds: "ss",
	fullDate: "ll",
	keyboardDate: "L",
	shortDate: "MMM D",
	normalDate: "D MMMM",
	normalDateWithWeekday: "ddd, MMM D",
	fullTime12h: "hh:mm A",
	fullTime24h: "HH:mm",
	keyboardDateTime12h: "L hh:mm A",
	keyboardDateTime24h: "L HH:mm"
};
var MISSING_UTC_PLUGIN = [
	"Missing UTC plugin",
	"To be able to use UTC or timezones, you have to enable the `utc` plugin",
	"Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"
].join("\n");
var MISSING_TIMEZONE_PLUGIN = [
	"Missing timezone plugin",
	"To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin",
	"Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"
].join("\n");
/**
* Based on `@date-io/dayjs`
*
* MIT License
*
* Copyright (c) 2017 Dmitriy Kovalenko
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
var AdapterDayjs = class {
	isMUIAdapter = true;
	isTimezoneCompatible = true;
	lib = "dayjs";
	escapedCharacters = {
		start: "[",
		end: "]"
	};
	formatTokenMap = (() => formatTokenMap)();
	constructor({ locale, formats } = {}) {
		this.locale = locale;
		this.formats = _extends({}, defaultFormats, formats);
		import_dayjs_min.default.extend(import_customParseFormat.default);
	}
	setLocaleToValue = (value) => {
		const expectedLocale = this.getCurrentLocaleCode();
		if (expectedLocale === value.locale()) return value;
		return value.locale(expectedLocale);
	};
	hasUTCPlugin = () => typeof import_dayjs_min.default.utc !== "undefined";
	hasTimezonePlugin = () => typeof import_dayjs_min.default.tz !== "undefined";
	isSame = (value, comparing, comparisonTemplate) => {
		const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
		return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
	};
	/**
	* Replaces "default" by undefined and "system" by the system timezone before passing it to `dayjs`.
	*/
	cleanTimezone = (timezone) => {
		switch (timezone) {
			case "default": return;
			case "system": return import_dayjs_min.default.tz.guess();
			default: return timezone;
		}
	};
	createSystemDate = (value) => {
		let date;
		if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
			const timezone = import_dayjs_min.default.tz.guess();
			if (timezone === "UTC") date = (0, import_dayjs_min.default)(value);
			else date = import_dayjs_min.default.tz(value, timezone);
		} else date = (0, import_dayjs_min.default)(value);
		return this.setLocaleToValue(date);
	};
	createUTCDate = (value) => {
		/* v8 ignore next 3 */
		if (!this.hasUTCPlugin()) throw new Error(MISSING_UTC_PLUGIN);
		return this.setLocaleToValue(import_dayjs_min.default.utc(value));
	};
	createTZDate = (value, timezone) => {
		/* v8 ignore next 3 */
		if (!this.hasUTCPlugin()) throw new Error(MISSING_UTC_PLUGIN);
		/* v8 ignore next 3 */
		if (!this.hasTimezonePlugin()) throw new Error(MISSING_TIMEZONE_PLUGIN);
		const keepLocalTime = value !== void 0 && !value.endsWith("Z");
		return this.setLocaleToValue((0, import_dayjs_min.default)(value).tz(this.cleanTimezone(timezone), keepLocalTime));
	};
	getLocaleFormats = () => {
		const locales = import_dayjs_min.default.Ls;
		let localeObject = locales[this.locale || "en"];
		if (localeObject === void 0) {
			warnOnce([
				"MUI X: Your locale has not been found.",
				"Either the locale key is not a supported one. Locales supported by dayjs are available here: https://github.com/iamkun/dayjs/tree/dev/src/locale.",
				"Or you forget to import the locale from 'dayjs/locale/{localeUsed}'",
				"fallback on English locale."
			]);
			/* v8 ignore stop */
			localeObject = locales.en;
		}
		return localeObject.formats;
	};
	/**
	* If the new day does not have the same offset as the old one (when switching to summer day time for example),
	* Then dayjs will not automatically adjust the offset (moment does).
	* We have to parse again the value to make sure the `fixOffset` method is applied.
	* See https://github.com/iamkun/dayjs/blob/b3624de619d6e734cd0ffdbbd3502185041c1b60/src/plugin/timezone/index.js#L72
	*/
	adjustOffset = (value) => {
		if (!this.hasTimezonePlugin()) return value;
		const timezone = this.getTimezone(value);
		if (timezone !== "UTC") {
			const fixedValue = value.tz(this.cleanTimezone(timezone), true);
			/* v8 ignore next 3 */
			if (fixedValue.$offset === (value.$offset ?? 0)) return value;
			value.$offset = fixedValue.$offset;
		}
		return value;
	};
	date = (value, timezone = "default") => {
		if (value === null) return null;
		if (timezone === "UTC") return this.createUTCDate(value);
		if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) return this.createSystemDate(value);
		return this.createTZDate(value, timezone);
	};
	getInvalidDate = () => (0, import_dayjs_min.default)(/* @__PURE__ */ new Date("Invalid date"));
	getTimezone = (value) => {
		if (this.hasTimezonePlugin()) {
			const zone = value.$x?.$timezone;
			if (zone) return zone;
		}
		if (this.hasUTCPlugin() && value.isUTC()) return "UTC";
		return "system";
	};
	setTimezone = (value, timezone) => {
		if (this.getTimezone(value) === timezone) return value;
		if (timezone === "UTC") {
			/* v8 ignore next 3 */
			if (!this.hasUTCPlugin()) throw new Error(MISSING_UTC_PLUGIN);
			return value.utc();
		}
		if (timezone === "system") return value.local();
		if (!this.hasTimezonePlugin()) {
			if (timezone === "default") return value;
			/* v8 ignore next */
			throw new Error(MISSING_TIMEZONE_PLUGIN);
		}
		return this.setLocaleToValue(import_dayjs_min.default.tz(value, this.cleanTimezone(timezone)));
	};
	toJsDate = (value) => {
		return value.toDate();
	};
	parse = (value, format) => {
		if (value === "") return null;
		return (0, import_dayjs_min.default)(value, format, this.locale, true);
	};
	getCurrentLocaleCode = () => {
		return this.locale || "en";
	};
	is12HourCycleInCurrentLocale = () => {
		/* v8 ignore next */
		return /A|a/.test(this.getLocaleFormats().LT || "");
	};
	expandFormat = (format) => {
		const localeFormats = this.getLocaleFormats();
		const t = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_, a, b) => a || b.slice(1));
		return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_, a, b) => {
			const B = b && b.toUpperCase();
			return a || localeFormats[b] || t(localeFormats[B]);
		});
	};
	isValid = (value) => {
		if (value == null) return false;
		return value.isValid();
	};
	format = (value, formatKey) => {
		return this.formatByString(value, this.formats[formatKey]);
	};
	formatByString = (value, formatString) => {
		return this.setLocaleToValue(value).format(formatString);
	};
	formatNumber = (numberToFormat) => {
		return numberToFormat;
	};
	isEqual = (value, comparing) => {
		if (value === null && comparing === null) return true;
		if (value === null || comparing === null) return false;
		return value.toDate().getTime() === comparing.toDate().getTime();
	};
	isSameYear = (value, comparing) => {
		return this.isSame(value, comparing, "YYYY");
	};
	isSameMonth = (value, comparing) => {
		return this.isSame(value, comparing, "YYYY-MM");
	};
	isSameDay = (value, comparing) => {
		return this.isSame(value, comparing, "YYYY-MM-DD");
	};
	isSameHour = (value, comparing) => {
		return value.isSame(comparing, "hour");
	};
	isAfter = (value, comparing) => {
		return value > comparing;
	};
	isAfterYear = (value, comparing) => {
		if (!this.hasUTCPlugin()) return value.isAfter(comparing, "year");
		return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
	};
	isAfterDay = (value, comparing) => {
		if (!this.hasUTCPlugin()) return value.isAfter(comparing, "day");
		return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
	};
	isBefore = (value, comparing) => {
		return value < comparing;
	};
	isBeforeYear = (value, comparing) => {
		if (!this.hasUTCPlugin()) return value.isBefore(comparing, "year");
		return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
	};
	isBeforeDay = (value, comparing) => {
		if (!this.hasUTCPlugin()) return value.isBefore(comparing, "day");
		return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
	};
	isWithinRange = (value, [start, end]) => {
		return value >= start && value <= end;
	};
	startOfYear = (value) => {
		return this.adjustOffset(value.startOf("year"));
	};
	startOfMonth = (value) => {
		return this.adjustOffset(value.startOf("month"));
	};
	startOfWeek = (value) => {
		return this.adjustOffset(this.setLocaleToValue(value).startOf("week"));
	};
	startOfDay = (value) => {
		return this.adjustOffset(value.startOf("day"));
	};
	endOfYear = (value) => {
		return this.adjustOffset(value.endOf("year"));
	};
	endOfMonth = (value) => {
		return this.adjustOffset(value.endOf("month"));
	};
	endOfWeek = (value) => {
		return this.adjustOffset(this.setLocaleToValue(value).endOf("week"));
	};
	endOfDay = (value) => {
		return this.adjustOffset(value.endOf("day"));
	};
	addYears = (value, amount) => {
		return this.adjustOffset(value.add(amount, "year"));
	};
	addMonths = (value, amount) => {
		return this.adjustOffset(value.add(amount, "month"));
	};
	addWeeks = (value, amount) => {
		return this.adjustOffset(value.add(amount, "week"));
	};
	addDays = (value, amount) => {
		return this.adjustOffset(value.add(amount, "day"));
	};
	addHours = (value, amount) => {
		return this.adjustOffset(value.add(amount, "hour"));
	};
	addMinutes = (value, amount) => {
		return this.adjustOffset(value.add(amount, "minute"));
	};
	addSeconds = (value, amount) => {
		return this.adjustOffset(value.add(amount, "second"));
	};
	getYear = (value) => {
		return value.year();
	};
	getMonth = (value) => {
		return value.month();
	};
	getDate = (value) => {
		return value.date();
	};
	getHours = (value) => {
		return value.hour();
	};
	getMinutes = (value) => {
		return value.minute();
	};
	getSeconds = (value) => {
		return value.second();
	};
	getMilliseconds = (value) => {
		return value.millisecond();
	};
	setYear = (value, year) => {
		return this.adjustOffset(value.set("year", year));
	};
	setMonth = (value, month) => {
		return this.adjustOffset(value.set("month", month));
	};
	setDate = (value, date) => {
		return this.adjustOffset(value.set("date", date));
	};
	setHours = (value, hours) => {
		return this.adjustOffset(value.set("hour", hours));
	};
	setMinutes = (value, minutes) => {
		return this.adjustOffset(value.set("minute", minutes));
	};
	setSeconds = (value, seconds) => {
		return this.adjustOffset(value.set("second", seconds));
	};
	setMilliseconds = (value, milliseconds) => {
		return this.adjustOffset(value.set("millisecond", milliseconds));
	};
	getDaysInMonth = (value) => {
		return value.daysInMonth();
	};
	getWeekArray = (value) => {
		const start = this.startOfWeek(this.startOfMonth(value));
		const end = this.endOfWeek(this.endOfMonth(value));
		let count = 0;
		let current = start;
		const nestedWeeks = [];
		while (current < end) {
			const weekNumber = Math.floor(count / 7);
			nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
			nestedWeeks[weekNumber].push(current);
			current = this.addDays(current, 1);
			count += 1;
		}
		return nestedWeeks;
	};
	getWeekNumber = (value) => {
		return value.week();
	};
	getDayOfWeek(value) {
		return value.day() + 1;
	}
	getYearRange = ([start, end]) => {
		const startDate = this.startOfYear(start);
		const endDate = this.endOfYear(end);
		const years = [];
		let current = startDate;
		while (this.isBefore(current, endDate)) {
			years.push(current);
			current = this.addYears(current, 1);
		}
		return years;
	};
};

//#endregion
export { AdapterDayjs };
//# sourceMappingURL=@mui_x-date-pickers_AdapterDayjs.js.map